---
title: "Approximate Network Matching"
author: 
  - name: Josiah Parry
    affiliation: Environmental Systems Research Institute, Redlands, CA, USA 
    orcid: 0000-0001-9910-865X
  - name: Robin Lovelace
    affiliation: Leeds Institute for Transport Studies, University of Leeds, UK
    orcid: 0000-0001-5679-6536
format: html
filters:
  - pseudocode
---

```{r, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


## Abstract 

Reconciling topologically different linestrings is a fundamental challenge in spatial data science, particularly when attempting to integrate network datasets from disparate sources. Existing methods often struggle with the absence of join keys and the need for wholesale joining of attributes, hindering effective data integration and analysis. In this paper, we propose a novel algorithm for matching two sets of linestrings, implemented in an open-source Rust library with bindings to R and Python. Our algorithm addresses the challenge by identifying topologically similar linestrings and estimating the shared length between each pair of matched linestrings. By leveraging R* spatial indices and angle-based matching criteria, our approach effectively reconciles linestrings with varying topologies. We demonstrate the utility of our algorithm through applications in spatial data analysis, including joins, weighted aggregations, and network subset identification based on shared characteristics. The proposed algorithm offers a robust solution for reconciling linestrings in spatial datasets, with implications for various domains in spatial data science.

<!--

- A common issue in spatial data science is the reconciliation of two sets of linestrings. 
- linestrings may represent the same phenomenon but be topologically different
- joining data between these road networks is problematic for many reasons
- often there may be no join key present
  - if there is a join key, there remains an issue of wholesale joining of attributes
    - attributes of a linestring are intended be associated with that linestring, not another
    - we need to do a join and provide a weight for future calculations 
- in this paper we introduce a new algorithm to match two sets of linestrings
- it is implemented in an open source rust library with bindings to R and Python
-->

## Problem Statement 

TODO 

## Existing algorithms 



## Algorithm overview 

The proposed algorithm aims to match elements of two sets of LineStrings that are topologically similar and estimate the amount of shared length between each pair of matched line strings.

Each LineString is composed of one or more Lines which is comprised of a single start or end point. The approximate network matching algorithm constructs two R* spatial indices over the component lines in $A$ and $B$. Intersection candidates between the two trees are used to limit the search space. For each candidate pair, the angle of the slopes are compared to determine if they are approximately parallel (parallelish). If the slopes are approximately parallel and the lines are within a minimum separable distance of each other, they are considered to match. The overlapping region between the matched lines is used to compute the shared length.

The result of the matching algorithm is a B-tree which can be used to generate a row-compressed sparse matrix.

### Identify match candidates

To identify matches between $A$ and $B$ we do not look at the LineStrings in their totality, but rather, by their individual components. $A$ and $B$ are comprised of one or more LineStrings index by $i$ and $j$ respectively. Each linestring is composed of one or more lines indexed as $k$. Matches are found between elements of $A_{ik}$ and $B_{jk}$ using two R-trees. 

We create an empty R-tree, $Tree_A$. For each line $A_{ik}$ we compute the slope of the line and insert the geometry, slope, and index into the tree. 

Next we create another empty R-tree, $Tree_B$, in which we will store each line in $B_{jk}$. However, instead of using the axis-aligned bounding box of $B_{jk}$, we create a newer, larger one, based on a distance tolerance, $DT$. The distance tolerance is used to expand the search for matches. We compute the AABB of $B_{jk}$, then expand the AABB by $DT$ in both the x and y directions. After doing so, we insert the geometry, slope, and index into $Tree_B$

```{r message = FALSE, echo = FALSE}
#| layout-ncol: 2
suppressMessages(library(sf))
library(rsgeo)
library(ggplot2)
library(patchwork)
conflicted::conflict_prefer("ggplot2", "rsgeo")

# box to crop geometry to
crop_box <- st_bbox(c("xmin" = 427200, xmax = 427500, ymin = 433550, ymax = 433700))

rnet_x <- "https://raw.githubusercontent.com/nptscot/networkmerge/main/data/rnet_armley.geojson" |> 
  read_sf() |>
  st_geometry() |> 
  st_transform(27700) |> 
  st_crop(crop_box)

rnet_y <- "https://raw.githubusercontent.com/nptscot/networkmerge/main/data/rnet_armley_line.geojson" |>
  read_sf() |> 
  st_crop(crop_box)



x <- as_rsgeo(sf::st_transform(rnet_x, 27700))
y <- as_rsgeo(st_transform(rnet_y, 27700))

# axis-aligned-bounding-box for x
xbb <- bounding_rect(explode_lines(x))

# creating bounding rects for y
# need to expand them
ybb <- bounding_rect(explode_lines(y))

# define function to expand the AABB
expand_aabb <- function(x, DT) {
  crds <- coords(x)
  # xmin, max, max, min, min
  # ymin min max max min
  crds[,1] <- crds[,1] + (c(-1, 1, 1, -1, -1)  * DT)
  crds[,2] <- crds[,2] + (c(-1, -1, 1, 1, -1)  * DT)
  rsgeo::geom_polygon(crds$x, crds$y, crds$polygon_id)
}

DT <- 2.5
xbb_sf <- st_as_sfc(xbb) |> st_set_crs(27700)
ybb_sf <- st_as_sfc(expand_aabb(ybb, DT)) |> st_set_crs(27700)

p1 <- ggplot() +
  geom_sf(
    data = xbb_sf, 
    fill = "#76b5c5", alpha = 0.25, lwd = 0.1
  ) +
  geom_sf(data = rnet_x, lwd = 0.2) +
  labs(title = "Axis-aligned-bounding-boxes of A") + 
  theme_void() 


p2 <- ggplot() +
  geom_sf(
    data = ybb_sf,
    fill = "#e28743", alpha = 0.25,lwd = 0.1
  ) +
  geom_sf(data = rnet_y, alpha = 0.5) +
  labs(
    title = "Axis-aligned-bounding-boxes of B",
    subtitle = paste0(DT, "meter distance tolerance")
  ) + 
  theme_void() 

p3 <- ggplot() +
  geom_sf(
    data = xbb_sf, 
    fill = "#76b5c5", alpha = 0.25, lwd = 0.1
  ) + 
  geom_sf(
    data = ybb_sf,
    fill = "#e28743", alpha = 0.25, lwd = 0.1
  ) + 
  geom_sf(data = rnet_x, alpha = 0.5, lwd = 0.15) +
  geom_sf(data = rnet_y, alpha = 0.5) +
  labs(title = "AABB and Networks Overlay") + 
  theme_void() 


p1
p2
```


If AABBs between $Tree_A$ and $Tree_B$ are intersecting, it means that that the lines $A_{ik}$ and $B_{jk}$ might be within $DT$ of each other and should be checked to see if they are considered matches. 

```{r}
p3
```


### Matching Criteria 

Candidate matches as determined by intersecting AABBs must then be further evaluated. Lines $A_{ik}$ and $B_{jk}$ must be approximately parallel (parallelish) to be considered a match. To this end, an angle tolerance $AT$ is defined. We take the inverse tangent of the slopes of lines $A_{ik}$ and $B_{jk}$ to find their angle. If the difference between these two angles are less than or equal to $AT$, we deem them tolerant or, parallelish.

```{r}
#| fig-cap: "Matched lines with 15Â° angle tolerance and 2.5 meter distance tolerance."
mtx <- rnetmatch::rnet_match(rnet_x, rnet_y, 2.5, 15)

i <- 4
ydx <- which(mtx$i == i)
xx <- rnet_x[i]
yy <- rnet_y$geometry[mtx$j[ydx]]

# plot the lines that we will measure 
plot(xx, lty = 3)
plot(yy, add = TRUE)
```



Being confident that the $A_{ik}$ and $B_{jk}$ are parallelish, we next need to determine if they are within the distance tolerance determined by $DT$. This is done by measuring the minimum separable distance between $A_{ik}$ and $B_{jk}$. If both conditions are satisfied, then the lines are matched. Following, the shared segment length must be calculated.

### Caclulating segment overlap 

Once two lines $A_{ik}$ and $B_{jk}$ have been determined to be matches, we need to evaluate how much overlap exists between the two lines. This overlap is defined by the segment length of $A_{ik}$ contained in the overlap in the x or y dimension between $A_{ik}$ or $B_{jk}$. 

Based on the angle of the line $A_{ik}$, $\theta_{A_{ik}}$, we either calculate the overlap in the line segments in either the x or y dimension. 

![](assets/line-seg-overlap-top.png)

If $\theta_{A_{ik}} \le 45^{\circ}$, we calculate the overlap between the range of x values of $A_{ik}$ and $B_{jk}$, $(x_{min}, x_{max})$. Using the slope of $A_{ik}$, solve for the values of y in the equation of the line. Using the calculated values of y, calculate the length of the line segment. If $\theta_{A_{ik}} \gt 45^{\circ}$, we instead calculate the overlap in the range of y values and subsequently solve for x, then calculate the length of the line segment. Note that if there is no overlap in the x or y dimension and even if both matching criteria were met, there will be no shared length, and the resultant value with be 0.


## Algorithm Implementation 

```pseudocode
#| label: alg-approx-net-matching
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true

\begin{algorithm}
\caption{Approximate Network Matching}
\begin{algorithmic}
\State // Initialize R-trees for LineString components in sets A and B
\Procedure{ApproxNetworkMatch}{$A, B, DT, AT$}
  \State $Tree_A \gets$ InitializeEmptyRTree()
  \For{each $A_{ik} \in A$}
    \State $slope_{A_{ik}} \gets$ ComputeSlope($A_{ik}$)
    \State InsertIntoRTree($Tree_A, i, A_{ik}, slope_{A_{ik}}$)
  \EndFor
  
  \State $Tree_B \gets$ InitializeEmptyRTree()
  \For{each $B_{jk} \in B$}
    \State $expandedAABB_{B_{jk}} \gets$ ExpandAABB($B_{jk}, DT$)
    \State InsertIntoRTree($Tree_B, j, B_{jk}, expandedAABB_{B_{jk}}$)
  \EndFor
  
  \State // Identify potential match candidates
  \For{each pair $(A_{ik}, B_{jk})$ with intersecting AABBs}
    \If{IsParallelish($slope_{A_{ik}}, slope_{B_{jk}}, AT$) and IsWithinDistance($A_{ik}, B_{jk}, DT$)}
      \State // Calculate shared segment length
      \State $overlapLength \gets$ CalculateOverlapLength($A_{ik}, B_{jk}$)
      \State // Store matched pair and overlap length
      \State StoreOrUpdateMatchedPair($A_{ik}, B_{jk}, overlapLength$)
    \EndIf
  \EndFor
  
  \State \Return MatchedPairs
\EndProcedure

\State // Helper functions
\Function{IsParallelish}{$slope_{A}, slope_{B}, AT$}
  \State $angle_A \gets \arctan(slope_{A})$
  \State $angle_B \gets \arctan(slope_{B})$
  \State \Return $(|angle_A - angle_B| \le AT)$
\EndFunction

\Function{IsWithinDistance}{$A_{ik}, B_{jk}, DT$}
  \State $minDistance \gets$ ComputeMinSeparableDistance($A_{ik}, B_{jk}$)
  \State \Return $(minDistance \le DT)$
\EndFunction

\Function{CalculateOverlapLength}{$A_{ik}, B_{jk}$}
  \State $\theta_{A_{ik}} \gets$ ComputeAngle($A_{ik}$)
  \If{$\theta_{A_{ik}} \le 45^\circ$}
    \State $overlapLength \gets$ CalculateXOverlap($A_{ik}, B_{jk}$)
  \Else
    \State $overlapLength \gets$ CalculateYOverlap($A_{ik}, B_{jk}$)
  \EndIf
  \State \Return $overlapLength$
\EndFunction
\end{algorithmic}
\end{algorithm}

```

## Applications 

- serves as the basis of joins and weighted aggregations
- NPT scottland 
- other possible use cases 
- can be used to subset networks based on shared characteristics e.g. road classification and matched between those subsets 

## Discussion

This algorithm is limited in that it is designed in $\Bbb{R}^2$ space. As such, there is no support for 3-dimensional or spherical coordinates. It is, however, conceivable to apply the same principles to these scenarios. The challenge, then, is to determine overlap regions, lengths, and lines-segments. 
